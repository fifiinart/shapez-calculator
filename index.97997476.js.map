{"mappings":"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","sources":["./src/assets/js/renderShape.ts","./src/assets/js/Color.ts","./src/assets/js/Shape.ts","./src/assets/js/operations/operation.ts","./src/assets/js/util.ts","./src/assets/js/operations/Paint.ts","./src/assets/js/index.ts"],"sourcesContent":["import { ColorHexCodes } from './Color'\nimport { Shape, SubShape } from './Shape'\n\ninterface Vector {\n  x: number, y: number\n}\n\nconst arrayQuadrantIndexToOffset: Vector[] = [\n  { x: 1, y: -1 }, // tr\n  { x: 1, y: 1 }, // br\n  { x: -1, y: 1 }, // bl\n  { x: -1, y: -1 } // tl\n]\n\nfunction beginCircle(this: CanvasRenderingContext2D, x: number, y: number, r: number): void {\n  if (r < 0.05) {\n    this.beginPath()\n    this.rect(x, y, 1, 1)\n    return\n  }\n  this.beginPath()\n  this.arc(x, y, r, 0, 2.0 * Math.PI)\n}\n\nfunction radians(degrees: number): number {\n  return (degrees * Math.PI) / 180.0\n}\n\nexport interface RenderShapeOptions {\n  backgroundColor: string;\n  w: number;\n  h: number;\n  shadowColor: string | false | null;\n  outlineColor: string | false | null;\n}\n\nconst renderShapeDefaults: RenderShapeOptions = {\n  backgroundColor: '#fff',\n  w: 512,\n  h: 512,\n  shadowColor: 'rgba(40, 50, 65, 0.1)',\n  outlineColor: '#555'\n}\n\nexport default function renderShape(this: CanvasRenderingContext2D, shape: Shape, options: Partial<RenderShapeOptions> = {}) {\n  const layers = shape.descriptor\n\n  const opts: RenderShapeOptions = Object.assign(renderShapeDefaults, options)\n\n  this.save()\n\n  const { w, h, shadowColor } = opts\n  this.canvas!.width = w\n  this.canvas!.height = h\n\n  this.fillStyle = opts.backgroundColor\n\n  const dpi = 1\n\n  this.fillRect(0, 0, w, h)\n\n  this.translate((w * dpi) / 2, (h * dpi) / 2)\n  this.scale((dpi * w) / 28, (dpi * h) / 28)\n\n  const quadrantSize = 10\n  const quadrantHalfSize = quadrantSize / 2\n\n  if (shadowColor) {\n    this.fillStyle = shadowColor\n    beginCircle.call(this, 0, 0, quadrantSize * 1.15)\n    this.fill()\n  }\n\n  for (let layerIndex = 0; layerIndex < layers.length; ++layerIndex) {\n    const quadrants = layers[layerIndex]\n\n    const layerScale = Math.max(0.1, 0.9 - layerIndex * 0.22)\n\n    for (let quadrantIndex = 0; quadrantIndex < 4; ++quadrantIndex) {\n      if (!quadrants[quadrantIndex]) {\n        continue\n      }\n      const { subShape, color } = quadrants[quadrantIndex]!\n\n      const quadrantPos = arrayQuadrantIndexToOffset[quadrantIndex]\n      const centerQuadrantX = quadrantPos.x * quadrantHalfSize\n      const centerQuadrantY = quadrantPos.y * quadrantHalfSize\n\n      const rotation = radians(quadrantIndex * 90)\n\n      this.translate(centerQuadrantX, centerQuadrantY)\n      this.rotate(rotation)\n\n      this.fillStyle = ColorHexCodes[color]\n      this.strokeStyle = opts.outlineColor || 'rgba(0, 0, 0, 0)'\n      this.lineWidth = 1\n\n      const insetPadding = 0.0\n\n      switch (subShape) {\n        case SubShape.rect: {\n          this.beginPath()\n          const dims = quadrantSize * layerScale\n          this.rect(\n            insetPadding + -quadrantHalfSize,\n            -insetPadding + quadrantHalfSize - dims,\n            dims,\n            dims\n          )\n\n          break\n        }\n        case SubShape.star: {\n          this.beginPath()\n          const dims = quadrantSize * layerScale\n\n          const originX = insetPadding - quadrantHalfSize\n          const originY = -insetPadding + quadrantHalfSize - dims\n\n          const moveInwards = dims * 0.4\n          this.moveTo(originX, originY + moveInwards)\n          this.lineTo(originX + dims, originY)\n          this.lineTo(originX + dims - moveInwards, originY + dims)\n          this.lineTo(originX, originY + dims)\n          this.closePath()\n          break\n        }\n\n        case SubShape.windmill: {\n          this.beginPath()\n          const dims = quadrantSize * layerScale\n\n          const originX = insetPadding - quadrantHalfSize\n          const originY = -insetPadding + quadrantHalfSize - dims\n          const moveInwards = dims * 0.4\n          this.moveTo(originX, originY + moveInwards)\n          this.lineTo(originX + dims, originY)\n          this.lineTo(originX + dims, originY + dims)\n          this.lineTo(originX, originY + dims)\n          this.closePath()\n          break\n        }\n\n        case SubShape.circle: {\n          this.beginPath()\n          this.moveTo(\n            insetPadding + -quadrantHalfSize,\n            -insetPadding + quadrantHalfSize\n          )\n          this.arc(\n            insetPadding + -quadrantHalfSize,\n            -insetPadding + quadrantHalfSize,\n            quadrantSize * layerScale,\n            -Math.PI * 0.5,\n            0\n          )\n          this.closePath()\n          break\n        }\n\n        default: {\n          throw new Error('Unkown sub shape: ' + subShape)\n        }\n      }\n\n      this.fill()\n      this.stroke()\n\n      this.rotate(-rotation)\n      this.translate(-centerQuadrantX, -centerQuadrantY)\n    }\n  }\n\n  this.restore()\n}\n","// From colors\n/** @enum {string} */\nexport enum Color {\n  red = \"red\",\n  green = \"green\",\n  blue = \"blue\",\n\n  yellow = \"yellow\",\n  purple = \"purple\",\n  cyan = \"cyan\",\n\n  white = \"white\",\n  uncolored = \"uncolored\",\n};\n\n/** @enum {string} */\nexport const ColorShortCode = {\n  [Color.red]: \"r\",\n  [Color.green]: \"g\",\n  [Color.blue]: \"b\",\n\n  [Color.yellow]: \"y\",\n  [Color.purple]: \"p\",\n  [Color.cyan]: \"c\",\n\n  [Color.white]: \"w\",\n  [Color.uncolored]: \"u\",\n} as const;\n\ntype ColorShortCode = typeof ColorShortCode;\n\n/** @enum {string} */\nexport const ColorHexCodes = {\n  [Color.red]: \"#ff666a\",\n  [Color.green]: \"#78ff66\",\n  [Color.blue]: \"#66a7ff\",\n\n  // red + green\n  [Color.yellow]: \"#fcf52a\",\n\n  // red + blue\n  [Color.purple]: \"#dd66ff\",\n\n  // blue + green\n  [Color.cyan]: \"#87fff5\",\n\n  // blue + green + red\n  [Color.white]: \"#ffffff\",\n\n  [Color.uncolored]: \"#aaaaaa\",\n} as const;\n\ntype ShortCodeToColor = {\n  [K in keyof ColorShortCode as ColorShortCode[K]]: K;\n};\n\nexport type ColorShortCodeUnion = keyof ShortCodeToColor;\n\n/** @enum {Color} */\nexport const ShortCodeToColor = {} as ShortCodeToColor;\nfor (const key in ColorShortCode) {\n  // @ts-ignore\n  ShortCodeToColor[ColorShortCode[key]] = key;\n}\n\n\nexport const possibleColorsString = Object.keys(ShortCodeToColor).join(\"\");","import { Color, ColorShortCode, ColorShortCodeUnion, possibleColorsString, ShortCodeToColor } from './Color'\n/** @enum {string} */\nexport enum SubShape {\n  rect = 'rect',\n  circle = 'circle',\n  star = 'star',\n  windmill = 'windmill',\n};\n\nexport type Quad = null | { subShape: SubShape; color: Color }\nexport type Layer = [Quad, Quad, Quad, Quad];\nexport type ShapeDescriptor = Layer[];\n\nexport const maxLayer = 4\n\n/** @enum {string} */\nexport const SubShapeShortCode = {\n  [SubShape.rect]: 'R',\n  [SubShape.circle]: 'C',\n  [SubShape.star]: 'S',\n  [SubShape.windmill]: 'W'\n} as const\n\ntype ShortCodeToSubShape = {\n  [K in keyof typeof SubShapeShortCode as typeof SubShapeShortCode[K]]: K;\n};\n\n/** @enum {SubShape} */\nconst ShortCodeToSubShape = {} as {\n  [K in keyof typeof SubShapeShortCode as typeof SubShapeShortCode[K]]: K;\n}\nfor (const key in SubShapeShortCode) {\n  // @ts-ignore\n  ShortCodeToSubShape[SubShapeShortCode[key]] = key\n}\n\nexport { ShortCodeToSubShape }\n\nexport const possibleShapesString = Object.keys(ShortCodeToSubShape).join('')\nexport const layerRegex = new RegExp(\n  '([' + possibleShapesString + '][' + possibleColorsString + ']|-{2}){4}'\n)\n\nexport type SubShapeShortCodeUnion = keyof ShortCodeToSubShape\n\nexport class ShortKeyConversionError extends Error { }\n\nexport class Shape {\n  private _descriptor: ShapeDescriptor;\n  get descriptor() { return this._descriptor }\n\n  constructor(descriptorOrKey: ShapeDescriptor) {\n    this._descriptor = descriptorOrKey\n  }\n\n  toString() {\n    return `Shape(${this.toShortKey()})`\n  }\n\n  [Symbol.iterator] = function* (this: Shape) {\n    yield* this.descriptor[Symbol.iterator]()\n  }.bind(this)\n\n  clone() {\n    const shape = this.descriptor\n    return new Shape(shape.map(layer => {\n      const mapped = layer.map<Quad>(quad => {\n        if (quad === null) return null\n        else return { ...quad }\n      })\n      if (mapped.length !== 4) throw new Error('Unexpected error in cloneShape: layer does not have 4 quads')\n      return mapped as Layer\n    }))\n  }\n\n  toShortKey() {\n    return this.descriptor.map(\n      l => l.map(\n        q => q === null\n          ? '--'\n          : SubShapeShortCode[q.subShape] + ColorShortCode[q.color]\n      ).join('')\n    ).join(':')\n  }\n\n  static fromShortKey(key: string) {\n    const sourceLayers = key.split(':')\n    if (!sourceLayers[0]) {\n      throw new ShortKeyConversionError('Expected 1-4 layers, recieved 0')\n    }\n    if (sourceLayers.length > maxLayer) {\n      throw new ShortKeyConversionError(`Expected 1-4 layers, recieved ${sourceLayers.length}`)\n    }\n\n    const layers = []\n    for (let i = 0; i < sourceLayers.length; ++i) {\n      const text = sourceLayers[i]\n      if (text.length !== 8) {\n        throw new ShortKeyConversionError(\"Invalid layer: '\" + text + \"' -> must be 8 characters\")\n      }\n\n      if (text === '--'.repeat(4)) {\n        throw new ShortKeyConversionError('Empty layers are not allowed')\n      }\n\n      if (!layerRegex.test(text)) {\n        throw new ShortKeyConversionError('Invalid syntax in layer ' + (i + 1))\n      }\n\n      const quads: Layer = [null, null, null, null]\n      for (let quad = 0; quad < 4; ++quad) {\n        const shapeText = text[quad * 2 + 0]\n        const subShape = ShortCodeToSubShape[shapeText as SubShapeShortCodeUnion]\n        const color = ShortCodeToColor[text[quad * 2 + 1] as ColorShortCodeUnion]\n        if (subShape) {\n          if (!color) {\n            throw new ShortKeyConversionError('Invalid shape color key: ' + key)\n          }\n          quads[quad] = {\n            subShape,\n            color\n          }\n        } else if (shapeText !== '-') {\n          throw new ShortKeyConversionError('Invalid shape key: ' + shapeText)\n        }\n      }\n      layers.push(quads)\n    }\n\n    return new Shape(layers)\n  }\n}\n","import { Shape } from \"../Shape\";\nimport { GameObject, getGameObjectType, isShape, TypeFromGameObject } from \"../util\";\n\nexport type OperationIngredient = GameObject | GameObject[]\nexport type OperationIngredientType<T> = T extends GameObject ? TypeFromGameObject<T> : T extends any[] ? { [K in keyof T]: OperationIngredientType<T[K]> } : never\nexport type OperationIngredientTypeList<T> = T extends OperationIngredient[] ? { [K in keyof T]: OperationIngredientType<T[K]> } : never\n\nexport interface OperationDescriptor<I extends OperationIngredient[], R extends OperationIngredient> {\n  name: string;\n  ingredients: OperationIngredientTypeList<I>;\n  result: OperationIngredientType<R>;\n  operate(ingredients: I): R\n}\n\nexport interface OperationSuccess<I extends OperationIngredient[], R extends OperationIngredient> {\n  name: string;\n  ingredients: I;\n  isError: false;\n  result: R;\n}\n\nexport interface OperationError<I extends OperationIngredient[]> {\n  name: string;\n  ingredients: I;\n  isError: true;\n  error: string;\n}\n\nexport type OperationResult<I extends OperationIngredient[], R extends OperationIngredient> = OperationSuccess<I, R> | OperationError<I>\n\nexport class OperationIngredientTypeMismatchError extends Error { }\nexport class OperationInvalidIngredientError extends Error { }\n\nexport interface Operation<I extends OperationIngredient[], R extends OperationIngredient> {\n  (ingredients: I): OperationResult<I, R>;\n}\n\nexport function createOperation<I extends OperationIngredient[], R extends OperationIngredient = Shape>(config: OperationDescriptor<I, R>): Operation<I, R> {\n  const op = function (ingredients: I): OperationResult<I, R> {\n    // validate ingredients\n    validateIngredientTypes<I>(ingredients, config.ingredients);\n    try {\n      let result = config.operate(ingredients);\n      return {\n        name: config.name,\n        ingredients,\n        isError: false,\n        result\n      };\n    } catch (e) {\n      if (e instanceof OperationInvalidIngredientError) {\n        return {\n          name: config.name,\n          ingredients,\n          isError: true,\n          error: e.message\n        }\n      } else throw e;\n    }\n\n  }\n  return op;\n}\n\nfunction validateIngredientTypes<I extends OperationIngredient[]>(ingredients: I, types: OperationIngredientTypeList<I>): void {\n  if (ingredients.length !== types.length)\n    throw new OperationIngredientTypeMismatchError(`Ingredient array length (${ingredients.length}) not equal to expected length (${types.length})`);\n  ingredients.forEach((ingredient, i) => {\n    const ingredientType = types[i];\n    if (ingredientType instanceof Array) {\n      if (!(ingredient instanceof Array)) throw new OperationIngredientTypeMismatchError(`Expected array, got '${ingredient}' in ingredient ${i}`)\n      if (ingredient.length !== ingredientType.length) throw new OperationIngredientTypeMismatchError(`Ingredient array length (${ingredient.length}) in ingredient ${i} not equal to expected length (${ingredientType.length})`);\n      try {\n        validateIngredientTypes(ingredient, ingredientType)\n      } catch (e) {\n        if (e instanceof OperationIngredientTypeMismatchError) {\n          e.message = e.message.replace(/ingredient/g, \"index\") + ` in ingredient ${i}`\n        }\n        throw e;\n      }\n    } else if (getGameObjectType(ingredient) !== ingredientType) throw new OperationIngredientTypeMismatchError(`Expected ${ingredientType}, got '${ingredient}' in ingredient ${i}`)\n  })\n}\n","/*\n * Lots of code here is copied 1:1 from actual game files\n *\n */\n\nimport { Color } from \"./Color\";\nimport { Layer, Shape, ShapeDescriptor, ShortKeyConversionError, SubShape } from \"./Shape\";\nexport interface GameObjectTypeDictionary {\n  shape: Shape;\n  color: Color;\n  boolean: boolean;\n}\n\nexport type GameObject = GameObjectTypeDictionary[keyof GameObjectTypeDictionary]\nexport type GameObjectType = keyof GameObjectTypeDictionary\n\nexport type TypeFromGameObject<T> =\n  T extends boolean ? \"boolean\" :\n  T extends Color ? \"color\" :\n  T extends Shape ? \"shape\" : never\n\nexport function isSubShape(subshape: unknown): subshape is SubShape {\n  return typeof subshape === \"string\" && !!SubShape[subshape as keyof typeof SubShape]\n}\n\nexport function isColor(color: unknown): color is Color {\n  return typeof color === \"string\" && color in Color\n}\n\nexport function isLayer(layer: unknown): layer is Layer {\n  if (!(layer instanceof Array && layer.length === 4)) return false;\n  if (layer.every(q => q === null)) return false;\n  return layer.every(quad => {\n    if (quad === null) return true;\n    if (!(quad instanceof Object)) return false;\n    if (!(\"subShape\" in quad && \"color\" in quad)) return false;\n    return isSubShape(quad.subShape) && isColor(quad.color);\n  })\n}\n\nexport function isShape(shape: unknown): shape is Shape {\n  return shape instanceof Shape;\n}\n\nexport function isShapeKey(key: unknown) {\n  if (typeof key !== \"string\") return false;\n  try {\n    Shape.fromShortKey(key);\n    return true;\n  } catch (e) {\n    if (e instanceof ShortKeyConversionError) return false;\n    else throw e;\n  }\n}\n\nexport function isShapeDescriptor(descriptor: unknown): descriptor is ShapeDescriptor {\n  if (!(descriptor instanceof Array && descriptor.length > 0 && descriptor.length <= 4)) return false;\n  return descriptor.every(isLayer);\n}\n\nexport function getGameObjectType(gameObject: unknown): GameObjectType | null {\n  if (typeof gameObject === 'boolean') return 'boolean';\n  if (isColor(gameObject)) return 'color';\n  if (isShape(gameObject)) return 'shape';\n  return null;\n}\n\n","import { Color } from \"../Color\";\nimport { Shape } from \"../Shape\";\nimport { createOperation, OperationInvalidIngredientError } from \"./operation\";\n\n// adapted from shapez.io::js/game/shape_definition::586\nfunction cloneAndPaintWith(shape: Shape, color: Color) {\n  if (color === Color.uncolored) throw new OperationInvalidIngredientError(\"A shape cannot be painted uncolored\")\n  const cloned = shape.clone().descriptor\n\n  for (let layerIndex = 0; layerIndex < cloned.length; ++layerIndex) {\n    const quadrants = cloned[layerIndex];\n    for (let quadrantIndex = 0; quadrantIndex < 4; ++quadrantIndex) {\n      const item = quadrants[quadrantIndex];\n      if (item) {\n        item.color = color;\n      }\n    }\n  }\n\n  return new Shape(cloned);\n}\n\n// adapted from shapez.io::js/game/shape_definition::601/\nfunction cloneAndPaintWith4Colors(shape: Shape, colors: [Color | null, Color | null, Color | null, Color | null]) {\n  if (colors.some(c => c === Color.uncolored)) throw new OperationInvalidIngredientError(\"A shape cannot be painted uncolored\")\n  const newLayers = shape.clone().descriptor\n\n  for (let layerIndex = 0; layerIndex < newLayers.length; ++layerIndex) {\n    const quadrants = newLayers[layerIndex];\n    for (let quadrantIndex = 0; quadrantIndex < 4; ++quadrantIndex) {\n      const item = quadrants[quadrantIndex];\n      const color = colors[quadrantIndex]\n      if (item && color) {\n        item.color = color;\n      }\n    }\n  }\n  return new Shape(newLayers)\n}\n\nexport const Paint = createOperation<[Shape, Color], Shape>({\n  name: 'Paint',\n  ingredients: ['shape', 'color'],\n  result: 'shape',\n  operate: (ingredients) => cloneAndPaintWith(...ingredients)\n})\n\nexport const QuadPaint = createOperation<[Shape, [Color, Color, Color, Color], [boolean, boolean, boolean, boolean]], Shape>({\n  name: 'QuadPaint',\n  ingredients: ['shape', ['color', 'color', 'color', 'color'], ['boolean', 'boolean', 'boolean', 'boolean']],\n  result: 'shape',\n  operate: ([shape, colors, bools]) => {\n    if (!(bools.some(b => !!b))) throw new OperationInvalidIngredientError(\"At least one wire must be activated\")\n\n    const activatedColors = colors.map((v, i) => bools[i] ? v : null) as [Color | null, Color | null, Color | null, Color | null]\n    return cloneAndPaintWith4Colors(shape, activatedColors)\n  }\n})\n\nexport const DoublePaint = createOperation<[[Shape, Shape], Color], [Shape, Shape]>({\n  name: 'DoublePaint',\n  ingredients: [['shape', 'shape'], 'color'],\n  result: ['shape', 'shape'],\n  operate: ([shapes, color]) => shapes.map(shape => cloneAndPaintWith(shape, color)) as [Shape, Shape]\n})\n","import renderShape from './renderShape'\nimport { Paint } from './operations/Paint'\nimport { getGameObjectType } from './util'\nimport { Shape, ShortKeyConversionError } from './Shape'\nconst textInput = document.getElementById('code') as HTMLInputElement\n\nconst errorMessage = document.getElementById('error') as HTMLParagraphElement\n\nconst canvas = document.getElementById('result') as HTMLCanvasElement\nconst ctx = canvas.getContext('2d')\n\nif (ctx == null) throw new Error('No context found for canvas')\n\nconst updateResult = () => {\n  try {\n    renderShape.call(ctx, Shape.fromShortKey(textInput.value))\n    errorMessage.textContent = 'Shape generated'\n    errorMessage.classList.remove('hasError')\n  } catch (err) {\n    if (err instanceof ShortKeyConversionError) {\n      errorMessage.textContent = 'Error: ' + err.message\n      errorMessage.classList.add('hasError')\n    } else if (err instanceof Error) { throw err }\n  }\n}\n\nupdateResult()\ntextInput.onchange = updateResult\n\nconst globalDebugFns = {\n  Paint,\n  Shape,\n  getGameObjectType\n}\n\nObject.assign(window, globalDebugFns)\n"],"names":["shape","options","layers","descriptor","opts","Object","assign","$ac89b1aa033cc435359672b1cc1fd378$var$renderShapeDefaults","this","save","w","h","shadowColor","canvas","width","height","fillStyle","backgroundColor","fillRect","translate","scale","quadrantSize","$ac89b1aa033cc435359672b1cc1fd378$var$beginCircle","call","fill","layerIndex","length","quadrants","layerScale","Math","max","quadrantIndex","subShape","color","quadrantPos","$ac89b1aa033cc435359672b1cc1fd378$var$arrayQuadrantIndexToOffset","centerQuadrantX","x","centerQuadrantY","y","rotation","PI","rotate","strokeStyle","outlineColor","lineWidth","insetPadding","rect","beginPath","dims","star","originX","originY","moveInwards","moveTo","lineTo","closePath","windmill","circle","arc","Error","stroke","restore","$bfa718a59790d2e6d809374d77884aca$var$Color","Color","$bfa718a59790d2e6d809374d77884aca$var$ColorShortCode","red","green","blue","yellow","purple","cyan","white","uncolored","$bfa718a59790d2e6d809374d77884aca$var$ColorHexCodes","$bfa718a59790d2e6d809374d77884aca$var$ShortCodeToColor","key","keys","join","$ebe62348e5dfcffb763f4fce950a5a48$var$SubShape","SubShape","$ebe62348e5dfcffb763f4fce950a5a48$var$SubShapeShortCode","$ebe62348e5dfcffb763f4fce950a5a48$var$ShortCodeToSubShape","$ebe62348e5dfcffb763f4fce950a5a48$var$possibleShapesString","$ebe62348e5dfcffb763f4fce950a5a48$var$layerRegex","RegExp","$bfa718a59790d2e6d809374d77884aca$exports","possibleColorsString","$ebe62348e5dfcffb763f4fce950a5a48$var$ShortKeyConversionError","$ebe62348e5dfcffb763f4fce950a5a48$var$Shape","_descriptor","constructor","descriptorOrKey","toString","toShortKey","Symbol","iterator","bind","clone","map","layer","mapped","quad","l","q","sourceLayers","split","i","text","repeat","test","quads","shapeText","push","r","config","ingredients","$b7ba4b9a10d21c148214b142fd7378db$var$validateIngredientTypes","result","operate","name","isError","e","$b7ba4b9a10d21c148214b142fd7378db$var$OperationInvalidIngredientError","error","message","fromShortKey","Array","every","$96684be4495df3857a094df6c8d22ac5$var$isLayer","gameObject","$96684be4495df3857a094df6c8d22ac5$var$isColor","$96684be4495df3857a094df6c8d22ac5$var$isShape","$96684be4495df3857a094df6c8d22ac5$var$isSubShape","subshape","$ebe62348e5dfcffb763f4fce950a5a48$exports","$b7ba4b9a10d21c148214b142fd7378db$var$OperationIngredientTypeMismatchError","types","forEach","ingredient","ingredientType","replace","$5dca62f81fcd97f2a2266b5734ba11d4$var$cloneAndPaintWith","cloned","item","$5dca62f81fcd97f2a2266b5734ba11d4$var$Paint","$5dca62f81fcd97f2a2266b5734ba11d4$var$QuadPaint","colors","bools","some","b","c","newLayers","$5dca62f81fcd97f2a2266b5734ba11d4$var$cloneAndPaintWith4Colors","v","$5dca62f81fcd97f2a2266b5734ba11d4$var$DoublePaint","shapes","$925fa03c9b2a2983f23d5c31793fbf5b$var$textInput","document","getElementById","$925fa03c9b2a2983f23d5c31793fbf5b$var$errorMessage","$925fa03c9b2a2983f23d5c31793fbf5b$var$ctx","getContext","$925fa03c9b2a2983f23d5c31793fbf5b$var$updateResult","value","textContent","classList","remove","err","add","onchange","$925fa03c9b2a2983f23d5c31793fbf5b$var$globalDebugFns","Paint","Shape","getGameObjectType","window"],"version":3,"file":"index.97997476.js.map"}